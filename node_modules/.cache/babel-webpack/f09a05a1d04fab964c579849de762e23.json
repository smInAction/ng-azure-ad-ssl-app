{"ast":null,"code":"/*! @azure/msal-common v4.4.0 2021-06-29 */\n'use strict';\n\nimport { Separators, CacheAccountType, CacheType, Constants } from '../../utils/Constants.js';\nimport { buildClientInfo } from '../../account/ClientInfo.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\nimport { AuthorityType } from '../../authority/AuthorityType.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      oboAssertion: access token passed in as part of OBO request\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n * }\r\n */\n\nvar AccountEntity =\n/** @class */\nfunction () {\n  function AccountEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountId = function () {\n    var accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountKey = function () {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  };\n  /**\r\n   * returns the type of the cache (in this case account)\r\n   */\n\n\n  AccountEntity.prototype.generateType = function () {\n    switch (this.authorityType) {\n      case CacheAccountType.ADFS_ACCOUNT_TYPE:\n        return CacheType.ADFS;\n\n      case CacheAccountType.MSAV1_ACCOUNT_TYPE:\n        return CacheType.MSA;\n\n      case CacheAccountType.MSSTS_ACCOUNT_TYPE:\n        return CacheType.MSSTS;\n\n      case CacheAccountType.GENERIC_ACCOUNT_TYPE:\n        return CacheType.GENERIC;\n\n      default:\n        {\n          throw ClientAuthError.createUnexpectedAccountTypeError();\n        }\n    }\n  };\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n\n\n  AccountEntity.prototype.getAccountInfo = function () {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims\n    };\n  };\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n\n\n  AccountEntity.generateAccountCacheKey = function (accountInterface) {\n    var accountKey = [accountInterface.homeAccountId, accountInterface.environment || \"\", accountInterface.tenantId || \"\"];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param clientInfo\r\n   * @param authority\r\n   * @param idToken\r\n   * @param policy\r\n   */\n\n\n  AccountEntity.createAccount = function (clientInfo, homeAccountId, authority, idToken, oboAssertion, cloudGraphHostName, msGraphHost) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var account = new AccountEntity();\n    account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    account.clientInfo = clientInfo;\n    account.homeAccountId = homeAccountId;\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n\n    account.environment = env; // non AAD scenarios can have empty realm\n\n    account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || \"\";\n    account.oboAssertion = oboAssertion;\n\n    if (idToken) {\n      account.idTokenClaims = idToken.claims; // How do you account for MSA CID here?\n\n      account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || \"\";\n      /*\r\n       * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.\r\n       * This field should not be relied upon if a custom policy is configured to return more than 1 email.\r\n       */\n\n      account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : \"\");\n      account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;\n    }\n\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  };\n  /**\r\n   * Builds non-AAD/ADFS account.\r\n   * @param authority\r\n   * @param idToken\r\n   */\n\n\n  AccountEntity.createGenericAccount = function (authority, homeAccountId, idToken, oboAssertion, cloudGraphHostName, msGraphHost) {\n    var _a, _b, _c, _d;\n\n    var account = new AccountEntity();\n    account.authorityType = authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = homeAccountId; // non AAD scenarios can have empty realm\n\n    account.realm = \"\";\n    account.oboAssertion = oboAssertion;\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n\n    if (idToken) {\n      // How do you account for MSA CID here?\n      account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || \"\"; // upn claim for most ADFS scenarios\n\n      account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || \"\";\n      account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || \"\";\n      account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;\n    }\n\n    account.environment = env;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    /*\r\n     * add uniqueName to claims\r\n     * account.name = idToken.claims.uniqueName;\r\n     */\n\n    return account;\n  };\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n\n\n  AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {\n    var _a;\n\n    var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING; // since ADFS does not have tid and does not set client_info\n\n    if (authType === AuthorityType.Adfs) {\n      return accountId;\n    } // for cases where there is clientInfo\n\n\n    if (serverClientInfo) {\n      try {\n        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n\n        if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\n          return \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;\n        }\n      } catch (e) {}\n    } // default to \"sub\" claim\n\n\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccountEntity.isAccountEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  };\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n\n\n  AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n\n    var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n\n    if (compareClaims) {\n      var accountAClaims = accountA.idTokenClaims || {};\n      var accountBClaims = accountB.idTokenClaims || {}; // issued at timestamp and nonce are expected to change each time a new id token is acquired\n\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && claimsMatch;\n  };\n\n  return AccountEntity;\n}();\n\nexport { AccountEntity };","map":{"version":3,"sources":["../../../src/cache/entities/AccountEntity.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Separators,\n    CacheAccountType,\n    CacheType,\n    Constants,\n} from \"../../utils/Constants\";\nimport { Authority } from \"../../authority/Authority\";\nimport { AuthToken } from \"../../account/AuthToken\";\nimport { ICrypto } from \"../../crypto/ICrypto\";\nimport { buildClientInfo } from \"../../account/ClientInfo\";\nimport { StringUtils } from \"../../utils/StringUtils\";\nimport { AccountInfo } from \"../../account/AccountInfo\";\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\nimport { AuthorityType } from \"../../authority/AuthorityType\";\nimport { Logger } from \"../../logger/Logger\";\nimport { TokenClaims } from \"../../account/TokenClaims\";\n\n/**\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\n *\n * Key : Value Schema\n *\n * Key: <home_account_id>-<environment>-<realm*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\n *      authorityType: Accounts authority type as a string\n *      name: Full name for the account, including given name and family name,\n *      clientInfo: Full base64 encoded client info received from ESTS\n *      lastModificationTime: last time this entity was modified in the cache\n *      lastModificationApp:\n *      oboAssertion: access token passed in as part of OBO request\n *      idTokenClaims: Object containing claims parsed from ID token\n * }\n */\nexport class AccountEntity {\n    homeAccountId: string;\n    environment: string;\n    realm: string;\n    localAccountId: string;\n    username: string;\n    authorityType: string;\n    name?: string;\n    clientInfo?: string;\n    lastModificationTime?: string;\n    lastModificationApp?: string;\n    oboAssertion?: string;\n    cloudGraphHostName?: string;\n    msGraphHost?: string; \n    idTokenClaims?: TokenClaims;\n\n    /**\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n     */\n    generateAccountId(): string {\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\n     */\n    generateAccountKey(): string {\n        return AccountEntity.generateAccountCacheKey({\n            homeAccountId: this.homeAccountId,\n            environment: this.environment,\n            tenantId: this.realm,\n            username: this.username,\n            localAccountId: this.localAccountId\n        });\n    }\n\n    /**\n     * returns the type of the cache (in this case account)\n     */\n    generateType(): number {\n        switch (this.authorityType) {\n            case CacheAccountType.ADFS_ACCOUNT_TYPE:\n                return CacheType.ADFS;\n            case CacheAccountType.MSAV1_ACCOUNT_TYPE:\n                return CacheType.MSA;\n            case CacheAccountType.MSSTS_ACCOUNT_TYPE:\n                return CacheType.MSSTS;\n            case CacheAccountType.GENERIC_ACCOUNT_TYPE:\n                return CacheType.GENERIC;\n            default: {\n                throw ClientAuthError.createUnexpectedAccountTypeError();\n            }\n        }\n    }\n\n    /**\n     * Returns the AccountInfo interface for this account.\n     */\n    getAccountInfo(): AccountInfo {\n        return {\n            homeAccountId: this.homeAccountId,\n            environment: this.environment,\n            tenantId: this.realm,\n            username: this.username,\n            localAccountId: this.localAccountId,\n            name: this.name,\n            idTokenClaims: this.idTokenClaims\n        };\n    }\n\n    /**\n     * Generates account key from interface\n     * @param accountInterface\n     */\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\n        const accountKey = [\n            accountInterface.homeAccountId,\n            accountInterface.environment || \"\",\n            accountInterface.tenantId || \"\",\n        ];\n\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\n     * @param clientInfo\n     * @param authority\n     * @param idToken\n     * @param policy\n     */\n    static createAccount(\n        clientInfo: string,\n        homeAccountId: string,\n        authority: Authority,\n        idToken: AuthToken,\n        oboAssertion?: string,\n        cloudGraphHostName?: string,\n        msGraphHost?: string\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n        account.clientInfo = clientInfo;\n        account.homeAccountId = homeAccountId;\n\n        const env = authority.getPreferredCache();\n        if (StringUtils.isEmpty(env)) {\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\n        }\n\n        account.environment = env;\n        // non AAD scenarios can have empty realm\n        account.realm = idToken?.claims?.tid || \"\";\n        account.oboAssertion = oboAssertion;\n        \n        if (idToken) {\n            account.idTokenClaims = idToken.claims;\n\n            // How do you account for MSA CID here?\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || \"\";\n\n            /*\n             * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.\n             * This field should not be relied upon if a custom policy is configured to return more than 1 email.\n             */\n            account.username = idToken?.claims?.preferred_username || (idToken?.claims?.emails? idToken.claims.emails[0]: \"\");\n            account.name = idToken?.claims?.name;\n        }\n\n        account.cloudGraphHostName = cloudGraphHostName;\n        account.msGraphHost = msGraphHost;\n\n        return account;\n    }\n\n    /**\n     * Builds non-AAD/ADFS account.\n     * @param authority\n     * @param idToken\n     */\n    static createGenericAccount(\n        authority: Authority,\n        homeAccountId: string,\n        idToken: AuthToken,\n        oboAssertion?: string,\n        cloudGraphHostName?: string,\n        msGraphHost?: string\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        account.authorityType = (authority.authorityType === AuthorityType.Adfs) ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\n        account.homeAccountId = homeAccountId;\n        // non AAD scenarios can have empty realm\n        account.realm = \"\";\n        account.oboAssertion = oboAssertion;\n\n        const env = authority.getPreferredCache();\n\n        if (StringUtils.isEmpty(env)) {\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\n        }\n\n        if (idToken) {\n            // How do you account for MSA CID here?\n            account.localAccountId = idToken?.claims?.oid || idToken?.claims?.sub || \"\";\n            // upn claim for most ADFS scenarios\n            account.username = idToken?.claims?.upn || \"\";\n            account.name = idToken?.claims?.name || \"\";\n            account.idTokenClaims = idToken?.claims;\n        }\n\n        account.environment = env;\n\n        account.cloudGraphHostName = cloudGraphHostName;\n        account.msGraphHost = msGraphHost;\n\n        /*\n         * add uniqueName to claims\n         * account.name = idToken.claims.uniqueName;\n         */\n\n        return account;\n    }\n\n    /**\n     * Generate HomeAccountId from server response\n     * @param serverClientInfo\n     * @param authType\n     */\n    static generateHomeAccountId(serverClientInfo: string, authType: AuthorityType, logger: Logger, cryptoObj: ICrypto, idToken?: AuthToken): string {\n\n        const accountId = idToken?.claims?.sub ? idToken.claims.sub : Constants.EMPTY_STRING;\n\n        // since ADFS does not have tid and does not set client_info\n        if (authType === AuthorityType.Adfs) {\n            return accountId;\n        }\n\n        // for cases where there is clientInfo\n        if (serverClientInfo) {\n            try {\n                const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\n                    return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\n                }\n            } catch (e) {}\n        }\n\n        // default to \"sub\" claim\n        logger.verbose(\"No client info in response\");\n        return accountId;\n    }\n\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccountEntity(entity: object): boolean {\n\n        if (!entity) {\n            return false;\n        }\n\n        return (\n            entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"localAccountId\") &&\n            entity.hasOwnProperty(\"username\") &&\n            entity.hasOwnProperty(\"authorityType\")\n        );\n    }\n\n    /**\n     * Helper function to determine whether 2 accountInfo objects represent the same account\n     * @param accountA \n     * @param accountB \n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\n     */\n    static accountInfoIsEqual(accountA: AccountInfo | null, accountB: AccountInfo | null, compareClaims?: boolean): boolean {\n        if (!accountA || !accountB) {\n            return false;\n        }\n\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n        if (compareClaims) {\n            const accountAClaims = (accountA.idTokenClaims || {}) as TokenClaims;\n            const accountBClaims = (accountB.idTokenClaims || {}) as TokenClaims;\n\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\n            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&\n            (accountAClaims.nonce === accountBClaims.nonce);\n        }\n\n        return (accountA.homeAccountId === accountB.homeAccountId) && \n            (accountA.localAccountId === accountB.localAccountId) &&\n            (accountA.username === accountB.username) &&\n            (accountA.tenantId === accountB.tenantId) &&\n            (accountA.environment === accountB.environment) &&\n            claimsMatch;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}