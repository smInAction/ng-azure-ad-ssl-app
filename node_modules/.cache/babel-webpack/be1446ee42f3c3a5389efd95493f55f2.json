{"ast":null,"code":"/*! @azure/msal-common v4.4.0 2021-06-29 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthorityType } from './AuthorityType.js';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { Constants, AuthorityMetadataSource } from '../utils/Constants.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ProtocolMode } from './ProtocolMode.js';\nimport { AuthorityMetadataEntity } from '../cache/entities/AuthorityMetadataEntity.js';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.js';\nimport { RegionDiscovery } from './RegionDiscovery.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\n\nvar Authority =\n/** @class */\nfunction () {\n  function Authority(authority, networkInterface, cacheManager, authorityOptions) {\n    this.canonicalAuthority = authority;\n\n    this._canonicalAuthority.validateAsUri();\n\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscovery = new RegionDiscovery(networkInterface);\n  }\n\n  Object.defineProperty(Authority.prototype, \"authorityType\", {\n    // See above for AuthorityType\n    get: function get() {\n      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n\n      if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {\n        return AuthorityType.Adfs;\n      }\n\n      return AuthorityType.Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"protocolMode\", {\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\n    get: function get() {\n      return this.authorityOptions.protocolMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"options\", {\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\n    get: function get() {\n      return this.authorityOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthority\", {\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\n    get: function get() {\n      return this._canonicalAuthority.urlString;\n    },\n\n    /**\r\n     * Sets canonical authority.\r\n     */\n    set: function set(url) {\n      this._canonicalAuthority = new UrlString(url);\n\n      this._canonicalAuthority.validateAsUri();\n\n      this._canonicalAuthorityUrlComponents = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthorityUrlComponents\", {\n    /**\r\n     * Get authority components.\r\n     */\n    get: function get() {\n      if (!this._canonicalAuthorityUrlComponents) {\n        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n      }\n\n      return this._canonicalAuthorityUrlComponents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"hostnameAndPort\", {\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tenant\", {\n    /**\r\n     * Get tenant for authority.\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"authorizationEndpoint\", {\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.authorization_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tokenEndpoint\", {\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"deviceCodeEndpoint\", {\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"endSessionEndpoint\", {\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.end_session_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"selfSignedJwtAudience\", {\n    /**\r\n     * OAuth issuer for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.issuer);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Replaces tenant in url path with current tenant. Defaults to common.\r\n   * @param urlString\r\n   */\n\n  Authority.prototype.replaceTenant = function (urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  };\n  /**\r\n   * Replaces path such as tenant or policy with the current tenant or policy.\r\n   * @param urlString\r\n   */\n\n\n  Authority.prototype.replacePath = function (urlString) {\n    var endpoint = urlString;\n    var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach(function (currentPart, index) {\n      var cachedPart = cachedAuthorityParts[index];\n\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(\"/\" + cachedPart + \"/\", \"/\" + currentPart + \"/\");\n      }\n    });\n    return endpoint;\n  };\n\n  Object.defineProperty(Authority.prototype, \"defaultOpenIdConfigurationEndpoint\", {\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\n    get: function get() {\n      if (this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC) {\n        return this.canonicalAuthority + \".well-known/openid-configuration\";\n      }\n\n      return this.canonicalAuthority + \"v2.0/.well-known/openid-configuration\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Boolean that returns whethr or not tenant discovery has been completed.\r\n   */\n\n  Authority.prototype.discoveryComplete = function () {\n    return !!this.metadata;\n  };\n  /**\r\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n   * and the /authorize, /token and logout endpoints.\r\n   */\n\n\n  Authority.prototype.resolveEndpointsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n\n            if (!metadataEntity) {\n              metadataEntity = new AuthorityMetadataEntity();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n\n            return [4\n            /*yield*/\n            , this.updateCloudDiscoveryMetadata(metadataEntity)];\n\n          case 1:\n            cloudDiscoverySource = _a.sent();\n            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n            return [4\n            /*yield*/\n            , this.updateEndpointMetadata(metadataEntity)];\n\n          case 2:\n            endpointSource = _a.sent();\n\n            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n              // Reset the expiration time unless both values came from a successful cache lookup\n              metadataEntity.resetExpiresAt();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n\n            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n            this.metadata = metadataEntity;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n   * @param metadataEntity\r\n   */\n\n\n  Authority.prototype.updateEndpointMetadata = function (metadataEntity) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, autodetectedRegionName, azureRegion;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            metadata = this.getEndpointMetadataFromConfig();\n\n            if (metadata) {\n              metadataEntity.updateEndpointMetadata(metadata, false);\n              return [2\n              /*return*/\n              , AuthorityMetadataSource.CONFIG];\n            }\n\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2\n              /*return*/\n              , AuthorityMetadataSource.CACHE];\n            }\n\n            return [4\n            /*yield*/\n            , this.getEndpointMetadataFromNetwork()];\n\n          case 1:\n            metadata = _b.sent();\n            if (!metadata) return [3\n            /*break*/\n            , 4];\n            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.regionDiscovery.detectRegion(this.authorityOptions.azureRegionConfiguration.environmentRegion)];\n\n          case 2:\n            autodetectedRegionName = _b.sent();\n            azureRegion = this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : this.authorityOptions.azureRegionConfiguration.azureRegion;\n\n            if (azureRegion) {\n              metadata = Authority.replaceWithRegionalInformation(metadata, azureRegion);\n            }\n\n            _b.label = 3;\n\n          case 3:\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return [2\n            /*return*/\n            , AuthorityMetadataSource.NETWORK];\n\n          case 4:\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n      });\n    });\n  };\n  /**\r\n   * Compares the number of url components after the domain to determine if the cached authority metadata can be used for the requested authority\r\n   * Protects against same domain different authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n   * @param metadataEntity\r\n   */\n\n\n  Authority.prototype.isAuthoritySameType = function (metadataEntity) {\n    var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  };\n  /**\r\n   * Parse authorityMetadata config option\r\n   */\n\n\n  Authority.prototype.getEndpointMetadataFromConfig = function () {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n   */\n\n\n  Authority.prototype.getEndpointMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint)];\n\n          case 1:\n            response = _a.sent();\n            return [2\n            /*return*/\n            , isOpenIdConfigResponse(response.body) ? response.body : null];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , null];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache and returns where the information was retrived from\r\n   * @param cachedMetadata\r\n   * @param newMetadata\r\n   */\n\n\n  Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.getCloudDiscoveryMetadataFromConfig();\n\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n              return [2\n              /*return*/\n              , AuthorityMetadataSource.CONFIG];\n            } // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n\n\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2\n              /*return*/\n              , AuthorityMetadataSource.CACHE];\n            }\n\n            return [4\n            /*yield*/\n            , this.getCloudDiscoveryMetadataFromNetwork()];\n\n          case 1:\n            metadata = _a.sent();\n\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n              return [2\n              /*return*/\n              , AuthorityMetadataSource.NETWORK];\n            } else {\n              // Metadata could not be obtained from config, cache or network\n              throw ClientConfigurationError.createUntrustedAuthorityError();\n            }\n\n        }\n      });\n    });\n  };\n  /**\r\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n   */\n\n\n  Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      try {\n        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n\n        if (metadata) {\n          return metadata;\n        }\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n      }\n    } // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n\n\n    if (this.isInKnownAuthorities()) {\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n\n    return null;\n  };\n  /**\r\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n   * @param networkInterface\r\n   */\n\n\n  Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var instanceDiscoveryEndpoint, match, response, metadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            instanceDiscoveryEndpoint = \"\" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + \"oauth2/v2.0/authorize\";\n            match = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint)];\n\n          case 2:\n            response = _a.sent();\n            metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\n\n            if (metadata.length === 0) {\n              // If no metadata is returned, authority is untrusted\n              return [2\n              /*return*/\n              , null];\n            }\n\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , null];\n\n          case 4:\n            if (!match) {\n              // Custom Domain scenario, host is trusted because Instance Discovery call succeeded \n              match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n            }\n\n            return [2\n            /*return*/\n            , match];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to determine if this host is included in the knownAuthorities config option\r\n   */\n\n\n  Authority.prototype.isInKnownAuthorities = function () {\n    var _this = this;\n\n    var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {\n      return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  };\n  /**\r\n   * Creates cloud discovery metadata object from a given host\r\n   * @param host\r\n   */\n\n\n  Authority.createCloudDiscoveryMetadataFromHost = function (host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  };\n  /**\r\n   * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n   * @param response\r\n   * @param authority\r\n   */\n\n\n  Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {\n    for (var i = 0; i < response.length; i++) {\n      var metadata = response[i];\n\n      if (metadata.aliases.indexOf(authority) > -1) {\n        return metadata;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * helper function to generate environment from authority object\r\n   */\n\n\n  Authority.prototype.getPreferredCache = function () {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n    }\n  };\n  /**\r\n   * Returns whether or not the provided host is an alias of this authority instance\r\n   * @param host\r\n   */\n\n\n  Authority.prototype.isAlias = function (host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  };\n  /**\r\n   * Checks whether the provided host is that of a public cloud authority\r\n   *\r\n   * @param authority string\r\n   * @returns bool\r\n   */\n\n\n  Authority.isPublicCloudAuthority = function (host) {\n    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  };\n  /**\r\n   * Rebuild the authority string with the region\r\n   *\r\n   * @param host string\r\n   * @param region string\r\n   */\n\n\n  Authority.buildRegionalAuthorityString = function (host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    var authorityUrlInstance = new UrlString(host);\n    authorityUrlInstance.validateAsUri();\n    var authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    var hostNameAndPort = region + \".\" + authorityUrlParts.HostNameAndPort;\n\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = region + \".\" + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;\n    } // Include the query string portion of the url\n\n\n    var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {\n      HostNameAndPort: hostNameAndPort\n    })).urlString; // Add the query string if a query string was provided\n\n    if (queryString) return url + \"?\" + queryString;\n    return url;\n  };\n  /**\r\n   * Replace the endpoints in the metadata object with their regional equivalents.\r\n   *\r\n   * @param metadata OpenIdConfigResponse\r\n   * @param azureRegion string\r\n   */\n\n\n  Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {\n    metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion); // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n\n    metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, \"allowestsrnonmsi=true\");\n    metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n    return metadata;\n  };\n\n  return Authority;\n}();\n\nexport { Authority };","map":{"version":3,"sources":["../../src/authority/Authority.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthorityType } from \"./AuthorityType\";\nimport { isOpenIdConfigResponse, OpenIdConfigResponse } from \"./OpenIdConfigResponse\";\nimport { UrlString } from \"../url/UrlString\";\nimport { IUri } from \"../url/IUri\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { AuthorityMetadataSource, Constants } from \"../utils/Constants\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ProtocolMode } from \"./ProtocolMode\";\nimport { ICacheManager } from \"../cache/interface/ICacheManager\";\nimport { AuthorityMetadataEntity } from \"../cache/entities/AuthorityMetadataEntity\";\nimport { AuthorityOptions } from \"./AuthorityOptions\";\nimport { CloudInstanceDiscoveryResponse, isCloudInstanceDiscoveryResponse } from \"./CloudInstanceDiscoveryResponse\";\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\nimport { RegionDiscovery } from \"./RegionDiscovery\";\n\n/**\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\n * endpoint. It will store the pertinent config data in this object for use during token calls.\n */\nexport class Authority {\n\n    // Canonical authority url string\n    private _canonicalAuthority: UrlString;\n    // Canonicaly authority url components\n    private _canonicalAuthorityUrlComponents: IUri | null;\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Cache Manager to cache network responses\n    protected cacheManager: ICacheManager;\n    // Protocol mode to construct endpoints\n    private authorityOptions: AuthorityOptions;\n    // Authority metadata\n    private metadata: AuthorityMetadataEntity;\n    // Region discovery service\n    private regionDiscovery: RegionDiscovery;\n\n    constructor(authority: string, networkInterface: INetworkModule, cacheManager: ICacheManager, authorityOptions: AuthorityOptions) {\n        this.canonicalAuthority = authority;\n        this._canonicalAuthority.validateAsUri();\n        this.networkInterface = networkInterface;\n        this.cacheManager = cacheManager;\n        this.authorityOptions = authorityOptions;\n        this.regionDiscovery = new RegionDiscovery(networkInterface);\n    }\n\n    // See above for AuthorityType\n    public get authorityType(): AuthorityType {\n        const pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n\n        if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {\n            return AuthorityType.Adfs;\n        }\n\n        return AuthorityType.Default;\n    }\n\n    /**\n     * ProtocolMode enum representing the way endpoints are constructed.\n     */\n    public get protocolMode(): ProtocolMode {\n        return this.authorityOptions.protocolMode;\n    }\n\n    /**\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\n     */\n    public get options(): AuthorityOptions {\n        return this.authorityOptions;\n    }\n\n    /**\n     * A URL that is the authority set by the developer\n     */\n    public get canonicalAuthority(): string {\n        return this._canonicalAuthority.urlString;\n    }\n\n    /**\n     * Sets canonical authority.\n     */\n    public set canonicalAuthority(url: string) {\n        this._canonicalAuthority = new UrlString(url);\n        this._canonicalAuthority.validateAsUri();\n        this._canonicalAuthorityUrlComponents = null;\n    }\n\n    /**\n     * Get authority components.\n     */\n    public get canonicalAuthorityUrlComponents(): IUri {\n        if (!this._canonicalAuthorityUrlComponents) {\n            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n        }\n\n        return this._canonicalAuthorityUrlComponents;\n    }\n\n    /**\n     * Get hostname and port i.e. login.microsoftonline.com\n     */\n    public get hostnameAndPort(): string {\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    }\n\n    /**\n     * Get tenant for authority.\n     */\n    public get tenant(): string {\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    }\n\n    /**\n     * OAuth /authorize endpoint for requests\n     */\n    public get authorizationEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.authorization_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth /token endpoint for requests\n     */\n    public get tokenEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    public get deviceCodeEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth logout endpoint for requests\n     */\n    public get endSessionEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.end_session_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth issuer for requests\n     */\n    public get selfSignedJwtAudience(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.issuer);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Replaces tenant in url path with current tenant. Defaults to common.\n     * @param urlString\n     */\n    private replaceTenant(urlString: string): string {\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n    }\n\n    /**\n     * Replaces path such as tenant or policy with the current tenant or policy.\n     * @param urlString \n     */\n    private replacePath(urlString: string): string {\n        let endpoint = urlString;\n        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n        const cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n\n        currentAuthorityParts.forEach((currentPart, index) => {\n            const cachedPart = cachedAuthorityParts[index];\n            if (currentPart !== cachedPart) {\n                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\n            }\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * The default open id configuration endpoint for any canonical authority.\n     */\n    protected get defaultOpenIdConfigurationEndpoint(): string {\n        if (this.authorityType === AuthorityType.Adfs || this.protocolMode === ProtocolMode.OIDC) {\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\n        }\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\n    }\n\n    /**\n     * Boolean that returns whethr or not tenant discovery has been completed.\n     */\n    discoveryComplete(): boolean {\n        return !!this.metadata;\n    }\n\n    /**\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\n     * and the /authorize, /token and logout endpoints.\n     */\n    public async resolveEndpointsAsync(): Promise<void> {\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n        if (!metadataEntity) {\n            metadataEntity = new AuthorityMetadataEntity();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cloudDiscoverySource = await this.updateCloudDiscoveryMetadata(metadataEntity);\n        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n        const endpointSource = await this.updateEndpointMetadata(metadataEntity);\n\n        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n            // Reset the expiration time unless both values came from a successful cache lookup\n            metadataEntity.resetExpiresAt();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        } \n\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n        this.metadata = metadataEntity;\n    }\n\n    /**\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\n     * @param metadataEntity \n     */\n    private async updateEndpointMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        let metadata = this.getEndpointMetadataFromConfig();\n        if (metadata) {\n            metadataEntity.updateEndpointMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        }\n\n        metadata = await this.getEndpointMetadataFromNetwork();\n        if (metadata) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                const autodetectedRegionName = await this.regionDiscovery.detectRegion(this.authorityOptions.azureRegionConfiguration.environmentRegion);\n\n                const azureRegion = this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG \n                    ? autodetectedRegionName \n                    : this.authorityOptions.azureRegionConfiguration.azureRegion;\n\n                if (azureRegion) {\n                    metadata = Authority.replaceWithRegionalInformation(metadata, azureRegion);\n                }\n            }\n\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        } else {\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n    }\n\n    /**\n     * Compares the number of url components after the domain to determine if the cached authority metadata can be used for the requested authority\n     * Protects against same domain different authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\n     * @param metadataEntity\n     */\n    private isAuthoritySameType(metadataEntity: AuthorityMetadataEntity): boolean {\n        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n        \n        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n    }\n\n    /**\n     * Parse authorityMetadata config option\n     */\n    private getEndpointMetadataFromConfig(): OpenIdConfigResponse | null {\n        if (this.authorityOptions.authorityMetadata) {\n            try {\n                return JSON.parse(this.authorityOptions.authorityMetadata) as OpenIdConfigResponse;\n            } catch (e) {\n                throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\n     */\n    private async getEndpointMetadataFromNetwork(): Promise<OpenIdConfigResponse | null> {\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync<OpenIdConfigResponse>(this.defaultOpenIdConfigurationEndpoint);\n            return isOpenIdConfigResponse(response.body) ? response.body : null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache and returns where the information was retrived from\n     * @param cachedMetadata \n     * @param newMetadata \n     */\n    private async updateCloudDiscoveryMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        let metadata = this.getCloudDiscoveryMetadataFromConfig();\n        if (metadata) {\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        }\n\n        metadata = await this.getCloudDiscoveryMetadataFromNetwork();\n        if (metadata) {\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        } else {\n            // Metadata could not be obtained from config, cache or network\n            throw ClientConfigurationError.createUntrustedAuthorityError();\n        }\n    }\n\n    /**\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\n     */\n    private getCloudDiscoveryMetadataFromConfig(): CloudDiscoveryMetadata | null {\n        // Check if network response was provided in config\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\n            try {\n                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata) as CloudInstanceDiscoveryResponse;\n                const metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n                if (metadata) {\n                    return metadata;\n                }\n            } catch (e) {\n                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n            }\n        }\n\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n        if (this.isInKnownAuthorities()) {\n            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n        }\n\n        return null;\n    }\n\n    /**\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\n     * @param networkInterface \n     */\n    private async getCloudDiscoveryMetadataFromNetwork(): Promise<CloudDiscoveryMetadata | null> {\n        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\n        let match = null;\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync<CloudInstanceDiscoveryResponse>(instanceDiscoveryEndpoint);\n            const metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\n            if (metadata.length === 0) {\n                // If no metadata is returned, authority is untrusted\n                return null;\n            }\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n        } catch(e) {\n            return null;\n        }\n\n        if (!match) {\n            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded \n            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n        }\n        return match;\n    } \n\n    /**\n     * Helper function to determine if this host is included in the knownAuthorities config option\n     */\n    private isInKnownAuthorities(): boolean {\n        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {\n            return UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;\n        });\n\n        return matches.length > 0;\n    }\n\n    /**\n     * Creates cloud discovery metadata object from a given host\n     * @param host \n     */\n    static createCloudDiscoveryMetadataFromHost(host: string): CloudDiscoveryMetadata {\n        return {\n            preferred_network: host,\n            preferred_cache: host,\n            aliases: [host]\n        };\n    }\n\n    /**\n     * Searches instance discovery network response for the entry that contains the host in the aliases list\n     * @param response \n     * @param authority \n     */\n    static getCloudDiscoveryMetadataFromNetworkResponse(response: CloudDiscoveryMetadata[], authority: string): CloudDiscoveryMetadata | null {\n        for (let i = 0; i < response.length; i++) {\n            const metadata = response[i];\n            if (metadata.aliases.indexOf(authority) > -1) {\n                return metadata;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * helper function to generate environment from authority object\n     */\n    getPreferredCache(): string {\n        if(this.discoveryComplete()) {\n            return this.metadata.preferred_cache;\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Returns whether or not the provided host is an alias of this authority instance\n     * @param host \n     */\n    isAlias(host: string): boolean {\n        return this.metadata.aliases.indexOf(host) > -1;\n    }\n\n    /**\n     * Checks whether the provided host is that of a public cloud authority\n     * \n     * @param authority string\n     * @returns bool\n     */\n    static isPublicCloudAuthority(host: string): boolean {\n        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n    }\n\n    /**\n     * Rebuild the authority string with the region\n     * \n     * @param host string\n     * @param region string \n     */\n    static buildRegionalAuthorityString(host: string, region: string, queryString?: string): string {\n        // Create and validate a Url string object with the initial authority string\n        const authorityUrlInstance = new UrlString(host);\n        authorityUrlInstance.validateAsUri();\n\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\n\n        let hostNameAndPort= `${region}.${authorityUrlParts.HostNameAndPort}`;\n\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\n        }\n\n        // Include the query string portion of the url\n        const url = UrlString.constructAuthorityUriFromObject({\n            ...authorityUrlInstance.getUrlComponents(),\n            HostNameAndPort: hostNameAndPort\n        }).urlString;\n\n        // Add the query string if a query string was provided\n        if (queryString) return `${url}?${queryString}`;\n\n        return url;\n    }\n\n    /**\n     * Replace the endpoints in the metadata object with their regional equivalents.\n     * \n     * @param metadata OpenIdConfigResponse\n     * @param azureRegion string\n     */\n    static replaceWithRegionalInformation(metadata: OpenIdConfigResponse, azureRegion: string): OpenIdConfigResponse {\n        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n        metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, \"allowestsrnonmsi=true\");\n        metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n        \n        return metadata;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}