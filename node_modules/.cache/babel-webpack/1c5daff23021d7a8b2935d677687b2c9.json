{"ast":null,"code":"/*! @azure/msal-browser v2.15.0 2021-06-29 */\n'use strict';\n\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class which exposes APIs to decode base64 strings to plaintext. See here for implementation details:\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_2_%E2%80%93_JavaScript's_UTF-16_%3E_UTF-8_%3E_base64\r\n */\n\nvar Base64Decode =\n/** @class */\nfunction () {\n  function Base64Decode() {}\n  /**\r\n   * Returns a URL-safe plaintext decoded string from b64 encoded input.\r\n   * @param input\r\n   */\n\n\n  Base64Decode.prototype.decode = function (input) {\n    var encodedString = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n    switch (encodedString.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        encodedString += \"==\";\n        break;\n\n      case 3:\n        encodedString += \"=\";\n        break;\n\n      default:\n        throw new Error(\"Invalid base64 string\");\n    }\n\n    var inputUtf8Arr = this.base64DecToArr(encodedString);\n    return BrowserStringUtils.utf8ArrToString(inputUtf8Arr);\n  };\n  /**\r\n   * Decodes base64 into Uint8Array\r\n   * @param base64String\r\n   * @param nBlockSize\r\n   */\n\n\n  Base64Decode.prototype.base64DecToArr = function (base64String, nBlockSize) {\n    var sB64Enc = base64String.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n    var nInLen = sB64Enc.length;\n    var nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;\n    var aBytes = new Uint8Array(nOutLen);\n\n    for (var nMod3 = void 0, nMod4 = void 0, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n      nMod4 = nInIdx & 3;\n      nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\n\n      if (nMod4 === 3 || nInLen - nInIdx === 1) {\n        for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n          aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n        }\n\n        nUint24 = 0;\n      }\n    }\n\n    return aBytes;\n  };\n  /**\r\n   * Base64 string to array decoding helper\r\n   * @param charNum\r\n   */\n\n\n  Base64Decode.prototype.b64ToUint6 = function (charNum) {\n    return charNum > 64 && charNum < 91 ? charNum - 65 : charNum > 96 && charNum < 123 ? charNum - 71 : charNum > 47 && charNum < 58 ? charNum + 4 : charNum === 43 ? 62 : charNum === 47 ? 63 : 0;\n  };\n\n  return Base64Decode;\n}();\n\nexport { Base64Decode };","map":{"version":3,"sources":["../../src/encode/Base64Decode.ts"],"names":[],"mappings":";;;;AAAA;;;;;AAOA;;;;;;;;AAIA,WAAA,YAAA,GAAA,CAoEC;;;;;;;AA9DG,EAAA,YAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAoB;AAChB,QAAI,aAAa,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,EAAoB,GAApB,EAAyB,OAAzB,CAAiC,IAAjC,EAAuC,GAAvC,CAApB;;AACA,YAAQ,aAAa,CAAC,MAAd,GAAuB,CAA/B;AACI,WAAK,CAAL;AACI;;AACJ,WAAK,CAAL;AACI,QAAA,aAAa,IAAI,IAAjB;AACA;;AACJ,WAAK,CAAL;AACI,QAAA,aAAa,IAAI,GAAjB;AACA;;AACJ;AACI,cAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AAVR;;AAaA,QAAM,YAAY,GAAG,KAAK,cAAL,CAAoB,aAApB,CAArB;AACA,WAAO,kBAAkB,CAAC,eAAnB,CAAmC,YAAnC,CAAP;AACH,GAjBD;;;;;;;;AAwBQ,EAAA,YAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAAuB,YAAvB,EAA6C,UAA7C,EAAgE;AAC5D,QAAM,OAAO,GAAG,YAAY,CAAC,OAAb,CAAqB,mBAArB,EAA0C,EAA1C,CAAhB;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;AACA,QAAM,OAAO,GAAG,UAAU,GAAG,IAAI,CAAC,IAAL,CAAU,CAAC,MAAM,GAAG,CAAT,GAAa,CAAb,KAAmB,CAApB,IAAyB,UAAnC,IAAiD,UAApD,GAAiE,MAAM,GAAG,CAAT,GAAa,CAAb,KAAmB,CAA9G;AACA,QAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,OAAf,CAAf;;AAEA,SAAK,IAAI,KAAK,GAAA,KAAA,CAAT,EAAW,KAAK,GAAA,KAAA,CAAhB,EAAkB,OAAO,GAAG,CAA5B,EAA+B,OAAO,GAAG,CAAzC,EAA4C,MAAM,GAAG,CAA1D,EAA6D,MAAM,GAAG,MAAtE,EAA8E,MAAM,EAApF,EAAwF;AACpF,MAAA,KAAK,GAAG,MAAM,GAAG,CAAjB;AACA,MAAA,OAAO,IAAI,KAAK,UAAL,CAAgB,OAAO,CAAC,UAAR,CAAmB,MAAnB,CAAhB,KAA+C,KAAK,IAAI,KAAnE;;AACA,UAAI,KAAK,KAAK,CAAV,IAAe,MAAM,GAAG,MAAT,KAAoB,CAAvC,EAA0C;AACtC,aAAK,KAAK,GAAG,CAAb,EAAgB,KAAK,GAAG,CAAR,IAAa,OAAO,GAAG,OAAvC,EAAgD,KAAK,IAAI,OAAO,EAAhE,EAAoE;AAChE,UAAA,MAAM,CAAC,OAAD,CAAN,GAAkB,OAAO,MAAM,OAAO,KAAP,GAAe,EAArB,CAAP,GAAkC,GAApD;AACH;;AACD,QAAA,OAAO,GAAG,CAAV;AACH;AACJ;;AAED,WAAO,MAAP;AACH,GAlBO;;;;;;;AAwBA,EAAA,YAAA,CAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,OAAnB,EAAkC;AAC9B,WAAO,OAAO,GAAG,EAAV,IAAgB,OAAO,GAAG,EAA1B,GACH,OAAO,GAAG,EADP,GAED,OAAO,GAAG,EAAV,IAAgB,OAAO,GAAG,GAA1B,GACE,OAAO,GAAG,EADZ,GAEI,OAAO,GAAG,EAAV,IAAgB,OAAO,GAAG,EAA1B,GACE,OAAO,GAAG,CADZ,GAEI,OAAO,KAAK,EAAZ,GACE,EADF,GAEI,OAAO,KAAK,EAAZ,GACE,EADF,GAGE,CAXpB;AAYH,GAbO;;AAcZ,SAAA,YAAA;AAAC,C","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\n\n/**\n * Class which exposes APIs to decode base64 strings to plaintext. See here for implementation details:\n * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_2_%E2%80%93_JavaScript's_UTF-16_%3E_UTF-8_%3E_base64\n */\nexport class Base64Decode {\n\n    /**\n     * Returns a URL-safe plaintext decoded string from b64 encoded input.\n     * @param input \n     */\n    decode(input: string): string {\n        let encodedString = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        switch (encodedString.length % 4) {\n            case 0:\n                break;\n            case 2:\n                encodedString += \"==\";\n                break;\n            case 3:\n                encodedString += \"=\";\n                break;\n            default:\n                throw new Error(\"Invalid base64 string\");\n        }\n\n        const inputUtf8Arr = this.base64DecToArr(encodedString);\n        return BrowserStringUtils.utf8ArrToString(inputUtf8Arr);\n    }\n\n    /**\n     * Decodes base64 into Uint8Array\n     * @param base64String \n     * @param nBlockSize \n     */\n    private base64DecToArr(base64String: string, nBlockSize?: number): Uint8Array {\n        const sB64Enc = base64String.replace(/[^A-Za-z0-9\\+\\/]/g, \"\");\n        const nInLen = sB64Enc.length;\n        const nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;\n        const aBytes = new Uint8Array(nOutLen);\n\n        for (let nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n            nMod4 = nInIdx & 3;\n            nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\n            if (nMod4 === 3 || nInLen - nInIdx === 1) {\n                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n                    aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n                }\n                nUint24 = 0;\n            }\n        }\n\n        return aBytes;\n    }\n\n    /**\n     * Base64 string to array decoding helper\n     * @param charNum \n     */\n    private b64ToUint6(charNum: number): number {\n        return charNum > 64 && charNum < 91 ?\n            charNum - 65\n            : charNum > 96 && charNum < 123 ? \n                charNum - 71\n                : charNum > 47 && charNum < 58 ?\n                    charNum + 4\n                    : charNum === 43 ?\n                        62\n                        : charNum === 47 ?\n                            63\n                            :\n                            0;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}