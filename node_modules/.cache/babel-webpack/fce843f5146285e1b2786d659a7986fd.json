{"ast":null,"code":"/*! @azure/msal-common v4.4.0 2021-06-29 */\n'use strict';\n\nimport { SERVER_TELEM_CONSTANTS, Constants, Separators } from '../../utils/Constants.js';\nimport { ServerTelemetryEntity } from '../../cache/entities/ServerTelemetryEntity.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar ServerTelemetryManager =\n/** @class */\nfunction () {\n  function ServerTelemetryManager(telemetryRequest, cacheManager) {\n    this.cacheManager = cacheManager;\n    this.apiId = telemetryRequest.apiId;\n    this.correlationId = telemetryRequest.correlationId;\n    this.forceRefresh = telemetryRequest.forceRefresh || false;\n    this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;\n    this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;\n    this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;\n  }\n  /**\r\n   * API to add MSER Telemetry to request\r\n   */\n\n\n  ServerTelemetryManager.prototype.generateCurrentRequestHeaderValue = function () {\n    var forceRefreshInt = this.forceRefresh ? 1 : 0;\n    var request = \"\" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + forceRefreshInt;\n    var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, request, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n  };\n  /**\r\n   * API to add MSER Telemetry for the last failed request\r\n   */\n\n\n  ServerTelemetryManager.prototype.generateLastRequestHeaderValue = function () {\n    var lastRequests = this.getLastRequests();\n    var maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n    var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    var errorCount = lastRequests.errors.length; // Indicate whether this header contains all data or partial data\n\n    var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;\n    var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n  };\n  /**\r\n   * API to cache token failures for MSER data capture\r\n   * @param error\r\n   */\n\n\n  ServerTelemetryManager.prototype.cacheFailedRequest = function (error) {\n    var lastRequests = this.getLastRequests();\n\n    if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {\n      // Remove a cached error to make room, first in first out\n      lastRequests.failedRequests.shift(); // apiId\n\n      lastRequests.failedRequests.shift(); // correlationId\n\n      lastRequests.errors.shift();\n    }\n\n    lastRequests.failedRequests.push(this.apiId, this.correlationId);\n\n    if (!StringUtils.isEmpty(error.subError)) {\n      lastRequests.errors.push(error.subError);\n    } else if (!StringUtils.isEmpty(error.errorCode)) {\n      lastRequests.errors.push(error.errorCode);\n    } else if (!!error && error.toString()) {\n      lastRequests.errors.push(error.toString());\n    } else {\n      lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);\n    }\n\n    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n    return;\n  };\n  /**\r\n   * Update server telemetry cache entry by incrementing cache hit counter\r\n   */\n\n\n  ServerTelemetryManager.prototype.incrementCacheHits = function () {\n    var lastRequests = this.getLastRequests();\n    lastRequests.cacheHits += 1;\n    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n    return lastRequests.cacheHits;\n  };\n  /**\r\n   * Get the server telemetry entity from cache or initialize a new one\r\n   */\n\n\n  ServerTelemetryManager.prototype.getLastRequests = function () {\n    var initialValue = new ServerTelemetryEntity();\n    var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);\n    return lastRequests || initialValue;\n  };\n  /**\r\n   * Remove server telemetry cache entry\r\n   */\n\n\n  ServerTelemetryManager.prototype.clearTelemetryCache = function () {\n    var lastRequests = this.getLastRequests();\n    var numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n    var errorCount = lastRequests.errors.length;\n\n    if (numErrorsFlushed === errorCount) {\n      // All errors were sent on last request, clear Telemetry cache\n      this.cacheManager.removeItem(this.telemetryCacheKey);\n    } else {\n      // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed\n      var serverTelemEntity = new ServerTelemetryEntity();\n      serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2); // failedRequests contains 2 items for each error\n\n      serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);\n      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);\n    }\n  };\n  /**\r\n   * Returns the maximum number of errors that can be flushed to the server in the next network request\r\n   * @param serverTelemetryEntity\r\n   */\n\n\n  ServerTelemetryManager.maxErrorsToSend = function (serverTelemetryEntity) {\n    var i;\n    var maxErrors = 0;\n    var dataSize = 0;\n    var errorCount = serverTelemetryEntity.errors.length;\n\n    for (i = 0; i < errorCount; i++) {\n      // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs\n      var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;\n      var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;\n      var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING; // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators\n\n      dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;\n\n      if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {\n        // Adding this entry to the header would still keep header size below the limit\n        maxErrors += 1;\n      } else {\n        break;\n      }\n    }\n\n    return maxErrors;\n  };\n\n  return ServerTelemetryManager;\n}();\n\nexport { ServerTelemetryManager };","map":{"version":3,"sources":["../../../src/telemetry/server/ServerTelemetryManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { SERVER_TELEM_CONSTANTS, Separators, Constants } from \"../../utils/Constants\";\nimport { CacheManager } from \"../../cache/CacheManager\";\nimport { AuthError } from \"../../error/AuthError\";\nimport { ServerTelemetryRequest } from \"./ServerTelemetryRequest\";\nimport { ServerTelemetryEntity } from \"../../cache/entities/ServerTelemetryEntity\";\nimport { StringUtils } from \"../../utils/StringUtils\";\n\nexport class ServerTelemetryManager {\n    private cacheManager: CacheManager;\n    private apiId: number;\n    private correlationId: string;\n    private forceRefresh: boolean;\n    private telemetryCacheKey: string;\n    private wrapperSKU: String;\n    private wrapperVer: String;\n\n    constructor(telemetryRequest: ServerTelemetryRequest, cacheManager: CacheManager) {\n        this.cacheManager = cacheManager;\n        this.apiId = telemetryRequest.apiId;\n        this.correlationId = telemetryRequest.correlationId;\n        this.forceRefresh = telemetryRequest.forceRefresh || false;\n        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;\n        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;\n\n        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;\n    }\n\n    /**\n     * API to add MSER Telemetry to request\n     */\n    generateCurrentRequestHeaderValue(): string {\n        const forceRefreshInt = this.forceRefresh ? 1 : 0;\n        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${forceRefreshInt}`;\n        const platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n\n        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, request, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n    }\n\n    /**\n     * API to add MSER Telemetry for the last failed request\n     */\n    generateLastRequestHeaderValue(): string {\n        const lastRequests = this.getLastRequests();\n\n        const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n        const failedRequests = lastRequests.failedRequests.slice(0, 2*maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n        const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n        const errorCount = lastRequests.errors.length;\n\n        // Indicate whether this header contains all data or partial data\n        const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;\n        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n\n        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n    }\n\n    /**\n     * API to cache token failures for MSER data capture\n     * @param error\n     */\n    cacheFailedRequest(error: AuthError): void {\n        const lastRequests = this.getLastRequests();\n        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {\n            // Remove a cached error to make room, first in first out\n            lastRequests.failedRequests.shift(); // apiId\n            lastRequests.failedRequests.shift(); // correlationId\n            lastRequests.errors.shift();\n        }\n        \n        lastRequests.failedRequests.push(this.apiId, this.correlationId);\n\n        if (!StringUtils.isEmpty(error.subError)) {\n            lastRequests.errors.push(error.subError);\n        } else if (!StringUtils.isEmpty(error.errorCode)) {\n            lastRequests.errors.push(error.errorCode);\n        } else if (!!error && error.toString()) {\n            lastRequests.errors.push(error.toString());\n        } else {\n            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);\n        }\n\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n\n        return;\n    }\n\n    /**\n     * Update server telemetry cache entry by incrementing cache hit counter\n     */\n    incrementCacheHits(): number {\n        const lastRequests = this.getLastRequests();\n        lastRequests.cacheHits += 1;\n\n        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n        return lastRequests.cacheHits;\n    }\n\n    /**\n     * Get the server telemetry entity from cache or initialize a new one\n     */\n    getLastRequests(): ServerTelemetryEntity {\n        const initialValue: ServerTelemetryEntity = new ServerTelemetryEntity();\n        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey) as ServerTelemetryEntity;\n\n        return lastRequests || initialValue;\n    }\n\n    /**\n     * Remove server telemetry cache entry\n     */\n    clearTelemetryCache(): void {\n        const lastRequests = this.getLastRequests();\n        const numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n        const errorCount = lastRequests.errors.length;\n        if (numErrorsFlushed === errorCount) {\n            // All errors were sent on last request, clear Telemetry cache\n            this.cacheManager.removeItem(this.telemetryCacheKey);\n        } else {\n            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed\n            const serverTelemEntity = new ServerTelemetryEntity();\n            serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed*2); // failedRequests contains 2 items for each error\n            serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);\n\n            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);\n        }\n    }\n\n    /**\n     * Returns the maximum number of errors that can be flushed to the server in the next network request\n     * @param serverTelemetryEntity\n     */\n    static maxErrorsToSend(serverTelemetryEntity: ServerTelemetryEntity): number {\n        let i;\n        let maxErrors = 0;\n        let dataSize = 0;\n        const errorCount = serverTelemetryEntity.errors.length;\n        for (i = 0; i < errorCount; i++) {\n            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs\n            const apiId = serverTelemetryEntity.failedRequests[2*i] || Constants.EMPTY_STRING;\n            const correlationId = serverTelemetryEntity.failedRequests[2*i + 1] || Constants.EMPTY_STRING;\n            const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;\n\n            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators\n            dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;\n\n            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {\n                // Adding this entry to the header would still keep header size below the limit\n                maxErrors += 1;\n            } else {\n                break;\n            }\n        }\n\n        return maxErrors;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}